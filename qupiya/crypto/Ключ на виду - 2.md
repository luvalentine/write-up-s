# Ключ на виду - 2 (400 pts)

## Условие
Есть сервис: кидаешь ему сообщение (hex), он шифрует.
По факту на сервере делается `zlib.compress( msg + FLAG )`, потом это шифруют CTR-ом.
Нужно вытащить `FLAG`.

## Анализ
CTR сам по себе норм, но длину не прячет.
А длина ciphertext = длина сжатого `zlib(...)`.
zlib любит совпадения: если в нашем msg есть кусок, который совпадает с началом/частью флага,
то сжатие чуть лучше → ciphertext короче.

## Уязвимость
Сжатие ДО шифрования:
`AES_CTR( zlib( user + FLAG ) )`
Это даёт утечку по длине (compression oracle).

## Решение
Подбираем флаг по символам:
- уже найденный префикс `qwe`
- пробуем добавить каждый символ `ch`
- отправляем `asd + qwe + ch`
- смотрим длину ответа
- где длина минимальная, там символ правильный
И так пока не дойдём до `}`.

## Код
```python
from pwn import remote

HOST = "asd"
PORT = 1337


abc = b"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_!-"

def ask(qwe, msg: bytes) -> int:
     qwe.recvuntil(b":")    
    qwe.sendline(msg.hex().encode())
    out = qwe.recvline().strip()   
    try:
        return len(bytes.fromhex(out.decode()))
    except:
        out = qwe.recvline().strip()
        return len(bytes.fromhex(out.decode()))

qwe = remote(HOST, PORT)

pref = b"qupiya{"
asd = b"A" * 64  

while not pref.endswith(b"}"):
    best = None
    bestL = 10**9

    for ch in abc:
        msg = asd + pref + bytes([ch])
        L = ask(qwe, msg)
        if L < bestL:
            bestL = L
            best = bytes([ch])

    pref += best
    print(pref)

print("FLAG:", pref.decode(errors="ignore"))
