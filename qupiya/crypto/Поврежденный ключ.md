

## Описание
В задаче дан повреждённый RSA-приватный ключ `corrupted_key.pem` и файл `ciphertext.txt`, содержащий два зашифрованных RSA-блока.  
Необходимо восстановить параметры приватного ключа и расшифровать сообщение, чтобы получить флаг.

---

## Анализ
Для расшифровки RSA требуется приватная экспонента `d` или простые множители `p` и `q`.

Формат PEM представляет собой base64-кодированный DER.  
Даже при повреждении файла часть base64-данных может сохраниться, что позволяет восстановить бинарное представление ключа.

В DER-структуре RSA-ключа большие значения (`p`, `q` и другие параметры) хранятся как ASN.1 `INTEGER`.  
Извлечение `p` и `q` полностью компрометирует RSA-ключ.

---

## Уязвимость
Файл приватного ключа был повреждён не полностью.  
Сохранённые base64-фрагменты внутри `corrupted_key.pem` содержали параметры `p` и `q`, чего достаточно для полного восстановления приватного ключа RSA.

---

## Решение

### 1. Ciphertext
Файл `ciphertext.txt` содержит два десятичных числа — два RSA-зашифрованных блока.

---

### 2. Восстановление DER
Файл `corrupted_key.pem` был прочитан как текст.  
Из него были извлечены строки, состоящие только из base64-символов (`A-Za-z0-9+/=`).  
Полученные строки были объединены и декодированы с помощью Base64, что дало бинарные DER-данные.

---

### 3. Разбор ASN.1
В DER ASN.1 значение типа `INTEGER` имеет следующий формат:
- тег `0x02`
- длина (короткая или длинная форма)
- байты числа

Был реализован минимальный парсер ASN.1 для последовательного чтения `INTEGER`.  
Из-за наличия мусора в начале DER разбор начинался с фиксированного смещения.

В результате:
- первый `INTEGER` соответствует `p`
- второй `INTEGER` соответствует `q`
- третий параметр не требуется для решения

---

### 4. Восстановление ключа
После получения `p` и `q` были вычислены стандартные параметры RSA:

- `n = p * q`
- `e = 65537`
- `phi = (p - 1) * (q - 1)`
- `d = e⁻¹ mod phi`

Таким образом была восстановлена приватная экспонента `d`.

---

### 5. Расшифровка
Каждый зашифрованный блок был расшифрован по формуле:

Так как размер модуля составляет 2048 бит, каждый расшифрованный блок имеет длину 256 байт.  
После преобразования в байты были удалены ведущие нулевые байты, затем оба блока объединены в одно сообщение.

---

## solve
```python
import re
import base64
from Crypto.Util.number import inverse, long_to_bytes

with open("ciphertext.txt") as f:
    c1 = int(f.readline())
    c2 = int(f.readline())

with open("corrupted_key.pem", errors="ignore") as f:
    key_text = f.read()

b64_lines = []
for line in key_text.splitlines():
    line = line.strip()
    if re.fullmatch(r"[A-Za-z0-9+/=]{16,}", line):
        b64_lines.append(line)

der = base64.b64decode("".join(b64_lines))

def read_int(buf, i):
    assert buf[i] == 0x02
    i += 1
    L = buf[i]
    i += 1
    if L & 0x80:
        nb = L & 0x7f
        L = int.from_bytes(buf[i:i+nb], "big")
        i += nb
    val = int.from_bytes(buf[i:i+L], "big")
    i += L
    return val, i

i = 5
p, i = read_int(der, i)
q, i = read_int(der, i)
_, i = read_int(der, i)

n = p * q
e = 65537
phi = (p - 1) * (q - 1)
d = inverse(e, phi)

m1 = pow(c1, d, n)
m2 = pow(c2, d, n)

b1 = long_to_bytes(m1, 256).lstrip(b"\x00")
b2 = long_to_bytes(m2, 256).lstrip(b"\x00")

msg = (b1 + b2).decode()
print(msg)

