## Описание
В задаче используется RSA с PKCS#1 v1.5.  
Сервис умеет проверять, корректен ли padding после расшифрования, и этим фактически выдаёт информацию о зашифрованном сообщении.

Даны:
- зашифрованный флаг `enc_flag`
- публичный ключ `pubkey.pem`
- набор чисел `R`

Формат флага стандартный.

---

## Анализ
Из исходного кода видно, что для каждого `r` из списка `R` значение  
`(m · r) mod N` всегда проходит проверку padding’а.

Для PKCS#1 v1.5 это означает, что расшифрованное сообщение начинается с `00 02` и лежит в диапазоне:
2B ≤ x < 3B

go
Копировать код
где `B = 2^(l-16)` и `l` — битовая длина модуля `N`.

Из этого условия для каждого `r` получается линейное соотношение:
k_i - r_i · m + 2B ≡ 0 (mod N)

yaml
Копировать код

Таким образом, задача сводится к **Hidden Number Problem**.

---

## Решение
1. Все полученные уравнения переводятся в вид системы линейных уравнений.
2. На их основе строится решётка.
3. К решётке применяется алгоритм LLL в SageMath.
4. Среди коротких векторов находится тот, который содержит значение `m`.
5. Из `m` напрямую восстанавливается флаг.

На практике значений из списка `R` оказалось недостаточно, поэтому был добавлен тривиальный множитель `r = 1`. После этого решётка успешно восстанавливает сообщение.

---

## Результат
Флаг был полностью восстановлен.

---

## Вывод
Если реализация RSA с PKCS#1 v1.5 различает валидный и невалидный padding,  
это приводит к утечке информации о сообщении.  
Даже такая проверка позволяет свести задачу к Hidden Number Problem и полностью сломать шифрование.
