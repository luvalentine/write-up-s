# Условие
# Дана зашифрованная строка и файл new_vigenere.py.
# Необходимо восстановить исходный текст и получить флаг
# в формате picoCTF{...}.

# Анализ
# Изучив код new_vigenere.py, можно увидеть, что используется
# модифицированный шифр Vigenere с алфавитом из 16 символов (a–p).
# Перед шифрованием флаг кодируется функцией b16_encode,
# которая превращает каждый символ в две буквы.

# В коде присутствует проверка, что флаг состоит только из символов
# 0123456789abcdef, то есть является hex-строкой.

# В ASCII у hex-символов есть особенность:
# - символы '0'–'9' имеют старшие биты равные 3
# - символы 'a'–'f' имеют старшие биты равные 6
# Функция b16_encode кодирует эти значения как:
# 3 → 'd', 6 → 'g'

# Следовательно, каждый первый символ пары после b16_encode
# (позиции 0, 2, 4, ...) всегда равен либо 'd', либо 'g'.
# Это даёт нам часть известного открытого текста.

# Шифрование выполняется по формуле:
# cipher = (plaintext + key) mod 16
# значит ключ можно вычислять как:
# key = (cipher - plaintext) mod 16

# Решение
# Так как ключ повторяется и имеет небольшую длину,
# я перебрал длину ключа от 1 до 14.
# Для каждой чётной позиции вычислялись возможные значения ключа
# (учитывая, что plaintext там равен 'd' или 'g').

# (скрипт) Для автоматизации я написал отдельный Python-скрипт,
# который:
# - перебирает длину ключа
# - восстанавливает возможные значения ключа
# - расшифровывает ciphertext
# - декодирует результат из b16
# - проверяет, что полученный текст состоит только из hex-символов

# В результате был найден единственный корректный вариант.

# Результат
# Найденный ключ:
# efedmlgbb

# Расшифрованный текст:
# ab20721f7c294d93ef6ec9c0a92419d9

# Финальный флаг:
# picoCTF{ab20721f7c294d93ef6ec9c0a92419d9}
