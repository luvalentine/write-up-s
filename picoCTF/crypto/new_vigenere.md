# Условие

Дана зашифрованная строка и файл new_vigenere.py.  
Необходимо проанализировать алгоритм шифрования и восстановить исходный текст,
после чего получить флаг в формате picoCTF{...}.

# Анализ

При изучении файла new_vigenere.py видно, что используется модифицированный
шифр Vigenere с алфавитом из 16 символов (a–p). Перед шифрованием флаг сначала
кодируется функцией b16_encode, из-за чего каждый символ превращается в две буквы.

В коде присутствует проверка, что флаг состоит только из символов
0123456789abcdef, то есть является hex-строкой.

ASCII-коды hex-символов имеют фиксированные старшие биты:
для символов '0'–'9' это значение 3, а для 'a'–'f' — значение 6.
Функция b16_encode переводит эти значения в буквы 'd' и 'g' соответственно.

Следовательно, каждый первый символ пары после b16_encode
(позиции 0, 2, 4 и т.д.) всегда равен либо 'd', либо 'g'.
Это даёт частично известный открытый текст.

Шифрование выполняется по формуле:
cipher = (plaintext + key) mod 16,
поэтому значение ключа можно вычислять как:
key = (cipher - plaintext) mod 16.

# Решение

Так как ключ повторяется и имеет небольшую длину, я перебрал возможную длину
ключа от 1 до 14. Для каждой чётной позиции вычислялись допустимые значения ключа,
учитывая, что открытый текст там равен 'd' или 'g'.

(скрипт) Для автоматизации процесса я написал отдельный Python-скрипт, который
перебирает длину ключа, восстанавливает возможные значения, расшифровывает текст,
декодирует результат из b16 и проверяет, что итоговая строка является корректной
hex-строкой.

В результате был найден единственный корректный вариант.

# Результат

Ключ шифрования:
efedmlgbb

Расшифрованный текст:
ab20721f7c294d93ef6ec9c0a92419d9

Флаг:
picoCTF{ab20721f7c294d93ef6ec9c0a92419d9}
