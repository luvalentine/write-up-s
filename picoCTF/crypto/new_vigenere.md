# writeup для new_vigenere.py

# сначала я открыл файл new_vigenere.py и посмотрел, как работает шифрование
# используется алфавит из 16 букв: a–p
# перед шифрованием флаг кодируется функцией b16_encode
# из-за этого каждый символ флага превращается в две буквы

# в коде есть проверка, что флаг состоит только из символов:
# 0123456789abcdef
# значит исходный текст — это hex-строка

# в ASCII у hex-символов есть особенность:
# '0'–'9' имеют старшие биты равные 3
# 'a'–'f' имеют старшие биты равные 6

# функция b16_encode переводит эти значения в буквы:
# 3 -> 'd'
# 6 -> 'g'

# поэтому каждый первый символ пары после b16_encode
# (позиции 0, 2, 4, 6 и т.д.)
# всегда равен либо 'd', либо 'g'
# это даёт нам часть известного открытого текста

# дальше применяется шифр Vigenere:
# cipher = (plaintext + key) mod 16
# значит ключ можно выразить так:
# key = (cipher - plaintext) mod 16

# для каждой чётной позиции я вычислял возможные значения ключа
# так как ключ короткий и повторяется,
# я перебрал длину ключа от 1 до 14

# (скрипт) для этого я написал отдельный python-скрипт,
# который:
# 1) перебирает длину ключа
# 2) вычисляет возможные значения ключа
# 3) расшифровывает весь текст
# 4) декодирует его из b16
# 5) проверяет, что результат состоит только из hex-символов

# в итоге подошёл только один корректный вариант

# найденный ключ:
# efedmlgbb

# расшифрованный текст:
# ab20721f7c294d93ef6ec9c0a92419d9

# итоговый флаг:
# picoCTF{ab20721f7c294d93ef6ec9c0a92419d9}
